/*H** FILENAME:		stereo.c** DESCRIPTION:	stereotactic realignment** NOTES:		mid-sagittal detection and AC-PC line detection** AUTHOR:		Satoshi Minoshima, MD, PhD** COPYRIGHT(c):	University of Washington (UW), 2003				Developed in the Neuroimaging and Biotechnology Laboratory				Satoshi Minoshima, MD, PhD** DATE:			05/30/2003** 	THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY OF WASHINGTON AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE UNIVERSITY OF WASHINGTON OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.**	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:		Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.				Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.				Neither the name of the University of Washington nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.		*	You agree to acknowledge UW and the developers on splash pages on start-up of your research software and in publications for research involving Software.*H*/#define TITLE	"STEREOTACTIC IMAGE REGISTRATION"/*** Standard ANSI Headers ***/#include		<stdio.h>#include		<stdlib.h>#include		<string.h>#include		<math.h>#include 		<ctype.h>/*** General Headers ***/#include		"images.h"#include		"affiliation.h"#include		"target.h"/*** Prototypes for Custom Functions ***/#include		"imageproc_lib.h"#include		"preference_lib.h"#include		"commandline_lib.h"#include		"fileio_lib.h"#include		"register_lib.h"#include		"filter_lib.h"#include		"process_lib.h"/*** Local Definitions ***//* Midsagittal and ACPC Iteration */#define			NDIM_MS				3#define			NDIM_ACPC			6#define			FTOL				1.0e-5		/* original 1.0e-6 */#define			CF_INIT				0.0#define			CF_ADD				0.5	/* ACPC QC Images */#define			QC_SLICES			6	/*** Local Variables and Constants ***//* Preference Parameters */static char		FnAtlas[MAXLINE+1];					/* atlas name */static ImageMatrix ImAtlas;							/* atlas image matrix */static int		AtlasXd, AtlasYd, AtlasZd;			/* atlas image dimensions */static float	AtlasPx, AtlasPy, AtlasPz;			/* atlas pixel size */static float	AtlasAcpc, AtlasAcpcCent;			/* atlas ACPC */static float	SearchOffsetMs, SearchCutoffMs, SearchOverlapMs;	/* mid-sagittal detection */static float	SearchOffsetAcpc, SearchCutoffAcpc, SearchOverlapAcpc;	/* ACPC line */static float	MagConstrainLow, MagConstrainHigh;	/* magnification constraints */static int		DisplayMsThick;						/* display mid-sagittal thickness */static int		DisplayMtThick;						/* display mid-transverse thickness */static int		DisplayMcThick;						/* display mid-coronal thickness */static float	ColorGridMinor, ColorGridMajor;		/* display grid colors */static int		MsMiBin1, MsMiBin2;					/* number of bins for MI in mid-sagittal detection */static int		AcpcMiBin1, AcpcMiBin2;				/* number of bins for MI in ACPC detection */static char		FnLandmark[MAXLINE+1];				/* landmark file name */static int		FlagLandmarkCoordinates;			/* flag for landmark file: 0=stereotactic coordinates and 1=pixel coordinates */static int		LandmarkNumMax;						/* maximum number of landmarks */static int		LandmarkBin;						/* number of bins for MI in landmark detection */static float	LandmarkMiMin;						/* minimum MI required for landmark detection */static float	LandmarkSearchLength;				/* search length (center to surface) x length(%) */static int		SearchLineSize;						/* search line size (width and height */static float	SearchMinVolume;					/* minimum line search volume */static float	MagnificationMax, MagnificationMin;	/* magnification for search line */static float	MagnificationStep;					/* search step for magnification */static float	ColorDest, ColorCent, ColorSurf;	/* landmark display color */static int		LandmarkFilterWidth;				/* bandpass filter size */static int		LandmarkCutoffLow, LandmarkCutoffHigh; /* bandpass cutoff (pixel), relative to Internal matrix size */static int		MidAcpcFilterWidth;					/* bandpass filter size */static int		MidAcpcCutoffLow, MidAcpcCutoffHigh; /* bandpass cutoff (pixel), relative to Internal matrix size */static float	LandmarkAsymmetry;					/* check landmark asymmetry */static int		FlagAPGrid;							/* flag for grid on AP.img */static float	XRotationMax, XRotationMin;			/* range for x rotation, 12/28/2002 */static float	StepAcpc1, StepAcpc2, StepAcpc3;	/* resampling step for acpc line search 5/30/2003 *//* Transformation parameters */static Pixel3D	OptimalTrans, OptimalRot, OptimalScale;	/* Optimal transformation parameters *//* Midsagittal Iteration */static int		MsStep;static int		MsBin;static int		MsCounter;static float	*MsImg, *MsX1, *MsX2, *MsX3, *MsY1, *MsY2, *MsY3;static float	*MsHist1, *MsHist2, **MsHist12;static float	MsCutoff, MsBinScale;static ImageHeader	*MsIh;/* ACPC Iteration */static int		AcpcStep;static int		AcpcBin;static int		AcpcCounter;static float	*AcpcImgAtlas, *AcpcImgTarget, *AcpcX1, *AcpcX2, *AcpcX3, *AcpcY1, *AcpcY2, *AcpcY3;static float	*AcpcHist1, *AcpcHist2, **AcpcHist12;static float	AcpcCutoffAtlas, AcpcCutoffTarget, AcpcBinScaleAtlas, AcpcBinScaleTarget;static float	IntAcpcLevel, AcpcSuperior, AcpcInferior;static ImageHeader	*AcpcIhAtlas, *AcpcIhTarget;/* others */static float	StdAcpcLevel;static float	OutofFieldValue;/* enumerated constants ***/enum OutputImage	{ NOIMAGE, TRANSPOSE, TRANSFORM, WARP, TRANSPOSE_WARP };enum Answer			{ NO, YES };enum OutputImage	FlagOutputImage;	/* enum flag:  types of output image */enum Answer			FlagLandmarkImage;	/* enum flag:  landmark image *//* pixel scaling factor */static float	PixelScale;/*** Prototypes for Local Functions ***/static void		iteration_midsagittal(float *parm, float *fret, float *img, ImageHeader *ih, NormValue *norm, int step, int bin);static void 	iteration_acpc(float *parm, float *fret, float *img1, ImageHeader *ih1, NormValue *norm1, float *img2, ImageHeader *ih2, NormValue *norm2, int step, int bin);static float	func_mi_midsagittal(float parm[]);static float	func_mi_acpc(float parm[]);static void		regional_matching(float *img1, float *img2, ImageHeader *ih, NormValue *NmTarget, NormValue *NmAtlas, Pixel3D *pixe, Pixel3D *pixc, Pixel3D *pixs, int num);static int	 	check_landmarks(Pixel3D *PixDest, Pixel3D *ixCent, Pixel3D *PixSurf, int LandmarkNum);static void 	display_landmarks(float *img, ImageHeader *ih, float avg, Pixel3D *pixs, Pixel3D *pixe, Pixel3D *pixc, int n);/*** Preference File ***/static void read_local_preference(char *FnPref){	/*	Read local preference file	DATE		WHO		DETAIL	09/16/1997	SM		Initial	11/18/1997	SM		Initial	*/	char	newline[MAXLINE+1], directory[MAXLINE+1], atlasname[MAXLINE+1], landname[MAXLINE+1];		FILE	*fpref;			/* check if preference.prf file exists */	if ((fpref = fopen(FnPref, "r")) == NULL) {		printf("%s does not exist...\n", FnPref);		if ((fpref = fopen(FnPref, "w")) == NULL) print_error_message(2, "can't create ", FnPref);	}	fclose(fpref);			/* get directry name for atlas and landmark files */	get_current_directory(directory, MAXLINE);	/* read (or determine) PREFERENCE (evaluator in lower cases) */	strcpy(atlasname, directory);	strcat(atlasname, "satlasB.img");	preference_string_strings(FnPref, FnAtlas, "Stereotactic Atlas File", atlasname);	ImAtlas.frame = preference_int_strings(FnPref, "Atlas Frame", 1);	ImAtlas.plane = preference_int_strings(FnPref, "Atlas Plane", 1);	ImAtlas.gate = preference_int_strings(FnPref, "Atlas Gate", 1);	ImAtlas.data = preference_int_strings(FnPref, "Atlas Data", 0);	ImAtlas.bed = preference_int_strings(FnPref, "Atlas Bed", 0);	AtlasXd = preference_int_strings(FnPref, "Atlas X Dimension", 128);	AtlasYd = preference_int_strings(FnPref, "Atlas Y Dimension", 128);	AtlasZd = preference_int_strings(FnPref, "Atlas Z Dimension", 60);	AtlasPx = preference_float_strings(FnPref, "Atlas X Pixel Size", 2.25);	AtlasPy = preference_float_strings(FnPref, "Atlas Y Pixel Size", 2.25);	AtlasPz = preference_float_strings(FnPref, "Atlas Z Pixel Size", 2.25);	AtlasAcpc = preference_float_strings(FnPref, "Atlas ACPC level", 32.0);	AtlasAcpcCent = preference_float_strings(FnPref, "Atlas ACPC midpoint (mm)", -16.0);		MidAcpcFilterWidth = preference_int_strings(FnPref, "Midsagittal Filter Size", 13);	MidAcpcCutoffLow = preference_int_strings(FnPref, "Midsagittal Low Cutoff", 0);	MidAcpcCutoffHigh = preference_int_strings(FnPref, "Midsagittal High Cutoff", 28);	SearchOffsetMs = preference_float_strings(FnPref, "Midsagittal Search Offset", 10.0);	SearchCutoffMs = preference_float_strings(FnPref, "Midsagittal Search Cutoff", 0.01);	SearchOverlapMs = preference_float_strings(FnPref, "Midsagittal Search Overlap", 0.50);	MsMiBin1 = preference_int_strings(FnPref, "Midsagittal MI Bins (first phase)", 8);	MsMiBin2 = preference_int_strings(FnPref, "Midsagittal MI Bins (second phase)", 16);	SearchOffsetAcpc = preference_float_strings(FnPref, "Acpc Search Offset", 20.0);	SearchCutoffAcpc = preference_float_strings(FnPref, "Acpc Search Cutoff", 0.01);	SearchOverlapAcpc = preference_float_strings(FnPref, "Acpc Search Overlap", 0.25);	AcpcSuperior = preference_float_strings(FnPref, "Acpc Search Volume (superior, mm)", 65.0);	AcpcInferior = preference_float_strings(FnPref, "Acpc Search Volume (inferior, mm)", 43.0);	AcpcMiBin1 = preference_int_strings(FnPref, "Acpc MI Bins (first phase)", 16);	AcpcMiBin2 = preference_int_strings(FnPref, "Acpc MI Bins (second phase)", 32);	StepAcpc1 = preference_int_strings(FnPref, "Acpc search resampling step 1", 3);	StepAcpc2 = preference_int_strings(FnPref, "Acpc search resampling step 2", 3);	StepAcpc3 = preference_int_strings(FnPref, "Acpc search resampling step 3", 2);	MagConstrainLow = preference_float_strings(FnPref, "Magnification Constraint low", -3.0);	MagConstrainHigh = preference_float_strings(FnPref, "Magnification Constraint high", 3.0);	XRotationMax = preference_float_strings(FnPref, "Maximum X Rotation Angle (degree)",  60.0);	/* 12/28/2002 */	XRotationMin = preference_float_strings(FnPref, "Minimum X Rotation Angle (degree)", -60.0);	DisplayMsThick = preference_int_strings(FnPref, "Display Midsagittal Thickness", 3);	DisplayMtThick = preference_int_strings(FnPref, "Display Midtransverse Thickness", 1);	DisplayMcThick = preference_int_strings(FnPref, "Display Midcoronal Thickness", 1);		ColorGridMinor = preference_float_strings(FnPref, "Display Color Grid Minor", 0.4);	ColorGridMajor = preference_float_strings(FnPref, "Display Color Grid Major", 0.7);	strcpy(landname, directory);	strcat(landname, "sland.dat");	preference_string_strings(FnPref, FnLandmark, "Stereotactic Landmark File", landname);	FlagLandmarkCoordinates = preference_int_strings(FnPref, "Landmark Coordinates (0=stereotactic (human); 1=pixel (internal))", 0);	LandmarkNumMax = preference_int_strings(FnPref, "Landmark Maximum Number", 300);	LandmarkBin = preference_int_strings(FnPref, "Landmark MI Bins", 8);	LandmarkMiMin = preference_float_strings(FnPref, "Landmark Minimum MI", 0.03);	LandmarkSearchLength = preference_float_strings(FnPref, "Landmark Search Length(%)", 1.5);	SearchLineSize = preference_int_strings(FnPref, "Landmark Search Line Size", 4);	SearchMinVolume = preference_float_strings(FnPref, "Landmark Minimum Search Volume(%)", 0.50);	MagnificationMax = preference_float_strings(FnPref, "Landmark Maximum Magnification", 1.30);	MagnificationMin = preference_float_strings(FnPref, "Landmark Minimum Magnification", 0.70);	MagnificationStep = preference_float_strings(FnPref, "Landmark Magnification Step", 0.01);	ColorDest = preference_float_strings(FnPref, "Landmark Color Destination(%)", 8.0);	ColorSurf = preference_float_strings(FnPref, "Landmark Color Surface(%)", 4.0);	ColorCent = preference_float_strings(FnPref, "Landmark Color Center(%)", 6.0);	LandmarkFilterWidth = preference_int_strings(FnPref, "Landmark Filter Size", 21);	LandmarkCutoffLow = preference_int_strings(FnPref, "Landmark Low Cutoff", 0);	LandmarkCutoffHigh = preference_int_strings(FnPref, "Landmark High Cutoff", 18);	LandmarkAsymmetry = preference_float_strings(FnPref, "Landmark Asymmetry(%)", 0.30);	FlagOutputImage = preference_int_strings(FnPref, "Create Output Images (0=none; 1=transposed; 2=transformed; 3=warped; 4=transposed+warped)", 3);	FlagLandmarkImage = preference_int_strings(FnPref, "Create Landmark Image (0=none; 1=yes)", 0);		PixelScale = preference_float_strings(FnPref, "Pixel Scaling Factor for binary output (0.0=normalized to max; 1.0=fixed; or exact)", 1.0);	FlagAPGrid = preference_int_strings(FnPref, "Proportional grid on AP quality control images (0=none; 1=yes)", 1);		OutofFieldValue = preference_float_strings(FnPref, "Pixel Value to Indicate Out of Field-of-View", 0.0);}/*** Main Routine ***/int main(int argc, char *argv[]){	int			i, j;						/* general loop counter */	int			sign;						/* iteration initialization */	int			LandmarkNum;				/* the number of hemispheric landmarks */	int			LandmarkNumTotal;			/* the number of total landmarks */	int			LandmarkNumEffective;		/* the number of determinant landmarks */	float		InvMatTargetInternal[16];	/* inverse matrix:  Target to Internal */	float		InvMatAtlasInternal[16];	/* inverse matrix:  Atlas to internal */	float		InvMatInternalStandard[16];	/* inverse matrix:  Internal to Standard */	float		InvMatStr[16];				/* inverse matrix:  ACPC */	float		InvMatTransform[16];		/* inverse matrix:  transformation */	float		InvMatTranslation[16];		/* inverse matrix:  translation */	float		InvMatPreWarp[16];			/* inverse matrix:  pre warping */	float		InvMatPostWarp[16];			/* inverse matrix:  post warping */	float		parm[NDIM_ACPC], parm_optimal[NDIM_ACPC];	/* ACPC iteration parameters */	float		cost_function, cost_function_min;	/* cost function for iteration */		float		*ImgTarget;					/* pointer for target image */	float		*ImgTargetInternal;			/* pointer for Internalized target image */	float		*ImgAtlas;					/* pointer for atlas image */	float		*ImgAtlasInternal;			/* pointer for internalized atlas image */	float		*ImgTargetStandard;			/* pointer for standardized target image */	float		*ImgQc;						/* pointer for quality control image */	float		*ImgSlice;					/* pointer for slice */		float		*BandpassFilter;			/* pointer to bandpass filter */	float		FilterScale;				/* filter scaling factor */	float		OffsetRotationX = 0.0;		/* Initial offset x-axis rotation, 12/28/2002, this value is set to 0.0 */		Pixel3D		CentInternal;				/* internal center point */	Pixel3D		AcpcTranslation;			/* ACPC translation */	Pixel3D		*PixCent;						/* pointer for predefined centers */	Pixel3D		*PixDest;						/* pointer for predefined destination landmarks */	Pixel3D		*PixSurf;						/* pointer for estimated surface landmarks  */		NormValue	NmTarget;					/* target image counts */	NormValue	NmAtlas;					/* atlas image counts */	ImageHeader	IhTarget;					/* image header:  target image */	ImageHeader	IhInternal;					/* image header:  internal matrix */	ImageHeader	IhTargetInternal;			/* image header:  internalized target */	ImageHeader	IhAtlas;					/* image header:  atlas */	ImageHeader	IhAtlasInternal;			/* image header:  internalized atlas */	ImageHeader	IhStandard;					/* image header:  standard */	ImageHeader	IhQc;						/* image header:  QC image */		ImageMatrix	ImTarget;					/* image matrix:  target image */		char		FnTarget[MAXLINE+1];		/* file name:  target image */	char		FnStrLibrary[MAXLINE+1];	/* file name:  str library file */	char		FnStrImage[MAXLINE+1];		/* file name:  output image file */	char		FnAcpcImage[MAXLINE+1];		/* file name:  ACPC QC image file */	char		FnLandmarkImage[MAXLINE+1];	/* file name:  landmark QC image file */	char		FnLandmarkLibrary[MAXLINE+1];	/* file name:  landmark file */	char		FnWarpImage[MAXLINE+1];		/* file name:  warped image */	char		ProgramDirectory[MAXLINE+1];  /* directory name where the program resides */	char		FnLocalPreference[MAXLINE+1]; /* local preference file name */	char		FnTargetHdr[MAXLINE+1]; 	/* target image file header *//*** initializing input parameters ***/	/* image frame */	ImTarget.frame  = 1;	ImTarget.plane  = 1;	ImTarget.gate   = 1;	ImTarget.data   = 0;	ImTarget.bed    = 0;/*** treatment for MacOS batch file ***/		/* set SIOUX setting based on batch status (Mac only, judged in the sioux_setting() */	if (batch_status() == 1) sioux_setting(1, 0); else sioux_setting(0, 0);		/*** read preference ***/		/* read command line (necessary for global and local preference files) */	read_command_line(&argc, &argv);	/* get directory name where the current program resides */	get_program_directory(argv[0], ProgramDirectory);		/* read global preference parameters (needs to be read after 'read_command_line' */	read_global_preference(ProgramDirectory);		/* read preference file (needs to be read prior to command line modifications) */	get_local_preference_name(argv[0], FnLocalPreference);	for (i = 1; i < argc; i++) if (argv[i][0] == '-' && argv[i][1] == 'p') strcpy(FnLocalPreference, &(argv[i][2]));	read_local_preference(FnLocalPreference);		/*** opening message ***/	/* write messages */	printf("\n%s (Version %3.1f)\n", TITLE, VERSION);	printf("%s\n%s\n%s\n%s\n%s\n", DEPARTMENT, HOSPITAL, ADDRESS, AUTHOR, TELFAX);	check_expiration(argv[0]);	printf("\n");/*** get command line information ***/	/* check command line */	if (argc < 3) {		printf("Command line: (image file name) (output file name w/o extension) (options)\n");		printf("\nOptions:\n");		printf("-f(frame); -b(bed position)\n");		printf("-o(output image: 0=none; 1=transposed; 2=transformed; 3=warped; 4=transposed+warped)\n");		printf("-l(landmark image: 0=no; 1=yes)\n");		printf("-h(\"common header\")\n");		printf("-p(\"local preference file name with directory\")\n");		printf("-q(pixel scaling factor for binary output: 0.0=normalized to max; 1.0=fixed; or exact)\n");		printf("-x(offset for x-axis rotation)\n");		printf("-v(pixel value for out of field-of-view in output image files");		printf("\nOutput:\n");		printf("(output file name)S.lib  - Stereotactic library file\n");		printf("(output file name)AP.img - Quality control AC-PC image file\n");		printf("(output file name)L.lib  - Nonlinear warping library file\n");		printf("(output file name)L.img  - Quality control landmark image file\n");		printf("(output file name)W.img  - Warped image file for scan\n");		printf("(output file name)SS.img - Transformed image file for scan\n");		printf("(output file name)S.img  - Transposed image file for scan\n");				exit(-1);	}		/* assign command line parameters */	strcpy(FnTarget, 		argv[1]);	strcpy(FnTargetHdr, 	argv[1]);	strcpy(FnStrLibrary,	argv[2]);	strcpy(FnStrImage,		argv[2]);	strcpy(FnAcpcImage,		argv[2]);	strcpy(FnLandmarkImage, argv[2]);	strcpy(FnLandmarkLibrary, argv[2]);	strcpy(FnWarpImage, 	argv[2]);	strcat(FnStrLibrary, 	"S.lib");	strcat(FnAcpcImage, 	"AP.img");	strcat(FnLandmarkImage, "L.img");	strcat(FnLandmarkLibrary, "L.lib");	strcat(FnWarpImage, 	"W.img");		/* read options and modify parameters */	for (i = 1; i < argc; i++) {		if (argv[i][0] == '-') {			switch(argv[i][1]) {					case 'f':	ImTarget.frame = atoi(&(argv[i][2]));						break;			case 'b':	ImTarget.bed = atoi(&(argv[i][2]));						break;			case 'o':	FlagOutputImage = atoi(&(argv[i][2]));						break;			case 'p':	strcpy(FnLocalPreference, &(argv[i][2]));						break;			case 'h':	strcpy(FnTargetHdr, &(argv[i][2]));						break;			case 'l':	FlagLandmarkImage = atoi(&(argv[i][2]));						break;			case 'q':	PixelScale = atof(&(argv[i][2]));						break;			case 'x':	OffsetRotationX = atof(&(argv[i][2]));						break;			case 'v':	OutofFieldValue = atof(&(argv[i][2]));						break;						}		}	}		/* pixel scaling factor for binary output */	if (PixelScale < 0.0) print_error_message(1, "illegal pixel scaling factor for binary output");	else FileFormat.scale = PixelScale;	/* determine output file name */	if (FlagOutputImage == TRANSPOSE || FlagOutputImage == TRANSPOSE_WARP) strcat(FnStrImage, "S.img");	else if (FlagOutputImage == TRANSFORM) strcat(FnStrImage, "SS.img");	else if (FlagOutputImage != NOIMAGE && FlagOutputImage != WARP) print_error_message(1, "illegal flag for image output (0-4)");	/* check flag */	if (FlagLandmarkImage != NO && FlagLandmarkImage != YES) print_error_message(1, "illegal flag for landmark image (0 or 1)");	if (FlagLandmarkCoordinates < 0 || FlagLandmarkCoordinates > 1) print_error_message(1, "illegal flag for landmark coordinates (0 or 1)");/****	ACPC LINE DETECTION***/printf("*** Bicommissural (AC-PC) Line Detection ***\n");/*** read target image file ***/	/* read header */	printf("reading target image file: %s...\n", FnTarget);	read_header(FnTargetHdr, &IhTarget, &FileFormat);	print_image_matrix_size(&IhTarget);	/* allocate memory */	ImgTarget = allocate_float_zero(image_size(&IhTarget), "ImgTarget");		/* read image */	read_image_planes(FnTarget, ImgTarget, &IhTarget, &ImTarget, &FileFormat);	/* calculate normalization parameters */	norm_histogram(ImgTarget, &IhTarget, INT_OutOfFieldCheck, &INT_NormSet, &NmTarget);	print_normvalue(&NmTarget);	/*** resample target image to internal matrix size ***/	/* calculate transform matrix */	printf("resampling target image...\n");	create_header_for_internal_matrix(&IhInternal);	create_header_for_resampled_matrix(&IhTarget, &IhInternal, &IhTargetInternal);	resample_matrix3d_inv(&IhTarget, &IhInternal, InvMatTargetInternal);	print_image_matrix_size(&IhTargetInternal);	/* allocate memory for resampled image */	ImgTargetInternal = allocate_float_zero(image_size(&IhTargetInternal), "ImgTargetInternal");		/* transform image */	transform3d_inv_img(ImgTarget, &IhTarget, ImgTargetInternal, &IhTargetInternal, InvMatTargetInternal, (INT_OutOfFieldCheck), (INT_OutOfFieldValue));	/* free memory */	free(ImgTarget);	/*** bandpass filtering of Internalized target image ***/	/* set bandpass filter */	printf("smoothing target image (%d-%d)...\n", MidAcpcCutoffLow, MidAcpcCutoffHigh);	BandpassFilter = allocate_float_zero(MidAcpcFilterWidth, "BandpassFilter");	bandpass_set_1d(BandpassFilter, MidAcpcFilterWidth, 7, MidAcpcCutoffLow, MidAcpcCutoffHigh, &FilterScale);	/* '7' assumes 128 (2^7) data length for FFT calculation */	filter3d_sym_fov(ImgTargetInternal, &IhTargetInternal, BandpassFilter, MidAcpcFilterWidth, FilterScale);	free(BandpassFilter);	/*** mid-sagittal detection ***/	/* first phase with offsets */	printf("searching the mid-sagittal plane (phase 1)...\n");	cost_function_min = CF_INIT;	for (sign = -1; sign <= 1; sign+=1) {		for (i = 0; i < NDIM_MS; i++) {					/* initialize parm[] */			for (j = 0; j < NDIM_MS; j++) {				parm[j] = 0.0;				if (j == i) parm[j] += (float)sign*SearchOffsetMs;			}						/* iteration */			iteration_midsagittal(parm, &cost_function, ImgTargetInternal, &IhTargetInternal, &NmTarget, 4, MsMiBin1);			/* check minimum cost function */			if (cost_function < cost_function_min) {				cost_function_min = cost_function;				for (j = 0; j < NDIM_MS; j++) parm_optimal[j] = parm[j];			}						/* if sign == 0, exit loop */			if (sign == 0) break;					}	}	if ( EQ(cost_function_min, CF_INIT) ) print_error_message(1, "error in the first phase of midsagittal detection");	else for (j = 0; j < NDIM_MS; j++) parm[j] = parm_optimal[j];	/* second phase */	printf("searching the mid-sagittal plane (phase 2)...\n");	iteration_midsagittal(parm, &cost_function, ImgTargetInternal, &IhTargetInternal, &NmTarget, 3, MsMiBin2);	iteration_midsagittal(parm, &cost_function, ImgTargetInternal, &IhTargetInternal, &NmTarget, 2, MsMiBin2);	if ( EQ(cost_function, CF_INIT) ) print_error_message(1, "error in the second phase of midsagittal detection");	else printf("translation x=%.1f; rotation y=%.1f; rotation z=%.1f\n", parm[0], parm[1], parm[2]);	/* update optimal parameters */	initialize_Pixel3D(&OptimalTrans);	initialize_Pixel3D(&OptimalRot);	initialize_Pixel3D(&OptimalScale);	OptimalTrans.x = parm[0];	OptimalRot.y   = parm[1];	OptimalRot.z   = parm[2];		/*** read standard atlas ***/	/* read header */	printf("reading stereotactic atlas: %s...\n", FnAtlas);	read_header(FnAtlas, &IhAtlas, &FileFormat);	print_image_matrix_size(&IhAtlas);	/* allocate memory */	ImgAtlas = allocate_float_zero(image_size(&IhAtlas), "ImgAtlas");		/* read image */	read_image_planes(FnAtlas, ImgAtlas, &IhAtlas, &ImAtlas, &FileFormat);	/* calculate normalization parameters */	norm_histogram(ImgAtlas, &IhAtlas, INT_OutOfFieldCheck, &INT_NormSet, &NmAtlas);	print_normvalue(&NmAtlas);/*** resample stereotactic atlas to internal matrix size ***/	/* calculate transform matrix */	printf("resampling stereotactic atlas...\n");	create_header_for_internal_matrix(&IhInternal);	create_header_for_resampled_matrix(&IhAtlas, &IhInternal, &IhAtlasInternal);	resample_matrix3d_inv(&IhAtlas, &IhInternal, InvMatAtlasInternal);	print_image_matrix_size(&IhAtlasInternal);	/* allocate memory for resampled image */	ImgAtlasInternal = allocate_float_zero(image_size(&IhAtlasInternal), "ImgAtlasInternal");		/* transform image */	transform3d_inv_img(ImgAtlas, &IhAtlas, ImgAtlasInternal, &IhAtlasInternal, InvMatAtlasInternal, INT_OutOfFieldCheck, INT_OutOfFieldValue);	/* free memory */	free(ImgAtlas);		/* calculate ACPC level in the internal image matrix */	IntAcpcLevel = calculate_acpc_level(AtlasAcpc, InvMatAtlasInternal);	printf("ACPC level in the internal image matrix: %4.1f...\n", IntAcpcLevel);	/*** AC-PC detection ***/	/* first phase with offsets */	printf("searching the AC-PC line (phase 1)...\n");	cost_function_min = CF_INIT;	for (sign = -1; sign <= 1; sign+=1) {		for (i = 0; i < NDIM_ACPC; i++) {					/* no offset for scaling parm[3-5] */			if (i >= 3) continue;					/* initialize parm[] */			for (j = 0; j < NDIM_ACPC; j++) {				parm[j] = 0.0;				if (j == 2) parm[j] = OffsetRotationX;				/* initial offset for x rotation */				if (j == i) parm[j] += (float)sign*SearchOffsetAcpc;			}						/* iteration */			iteration_acpc(parm, &cost_function, ImgAtlasInternal, &IhAtlasInternal, &NmAtlas, ImgTargetInternal, &IhTargetInternal, &NmTarget, StepAcpc1, AcpcMiBin1);			/* check minimum cost function */			if (cost_function < cost_function_min) {				cost_function_min = cost_function;				for (j = 0; j < NDIM_ACPC; j++) parm_optimal[j] = parm[j];			}						/* if sign == 0, exit loop */			if (sign == 0) break;					}	}	if ( EQ(cost_function_min, CF_INIT) ) print_error_message(1, "error in the first phase of ACPC detection");	else for (j = 0; j < NDIM_ACPC; j++) parm[j] = parm_optimal[j];		/* second phase */	printf("searching the AC-PC line (phase 2)...\n");	iteration_acpc(parm, &cost_function, ImgAtlasInternal, &IhAtlasInternal, &NmAtlas, ImgTargetInternal, &IhTargetInternal, &NmTarget, StepAcpc2, AcpcMiBin2);	/* change back to 3 and 2 in Version 6.9 */	iteration_acpc(parm, &cost_function, ImgAtlasInternal, &IhAtlasInternal, &NmAtlas, ImgTargetInternal, &IhTargetInternal, &NmTarget, StepAcpc3, AcpcMiBin2);	if ( EQ(cost_function, CF_INIT) ) print_error_message(1, "error in the second phase of ACPC detection");	else printf("translation y=%.1f; translation z=%.1f; rotation x=%.1f\nscale x=%.1f; scale y=%.1f; scale z=%.1f\n", parm[0], parm[1],parm[2],parm[3],parm[4],parm[5]);	/* update optimal parameters */	OptimalTrans.y = parm[0];	OptimalTrans.z = parm[1];	OptimalRot.x   = parm[2];	OptimalScale.x = 1.0 + parm[3] * 0.1;	OptimalScale.y = 1.0 + parm[4] * 0.1;	OptimalScale.z = 1.0 + parm[5] * 0.1;		/* free image memory */	free(ImgAtlasInternal);	free(ImgTargetInternal);		/*** calculate ACPC level in the standard image ***/	/* calculate ACPC level in the standard image matrix */	create_header_for_internal_matrix(&IhInternal);	create_header_for_standard_matrix(&IhStandard);	resample_matrix3d_inv(&IhAtlas, &IhInternal, InvMatAtlasInternal);	resample_matrix3d_inv(&IhInternal, &IhStandard, InvMatInternalStandard);	multiply_matrix4(InvMatAtlasInternal, InvMatInternalStandard, InvMatTransform);	StdAcpcLevel = calculate_acpc_level(AtlasAcpc, InvMatTransform);	printf("ACPC level in the transformed image matrix: %4.1f...\n", StdAcpcLevel);		/* calculate translation matrix to match the above ACPC to predefined STD_Acpc */	AcpcTranslation.x = AcpcTranslation.y = 0.0;	AcpcTranslation.z = STD_Acpc - StdAcpcLevel;	translation3d_inv(&AcpcTranslation, InvMatTranslation);		/*** transform original target image to standard image ***/	/* read header */	printf("reading target image file: %s...\n", FnTarget);	ImgTarget = allocate_float_zero(image_size(&IhTarget), "ImgTarget");	read_image_planes(FnTarget, ImgTarget, &IhTarget, &ImTarget, &FileFormat);	/* create matrix for standard output image file */	printf("standardizing target image...\n");	create_header_for_standard_matrix(&IhStandard);	ImgTargetStandard = allocate_float_zero(image_size(&IhStandard), "ImgTargetStandard");		/* if output image, */	if (FlagOutputImage == TRANSPOSE || FlagOutputImage == TRANSPOSE_WARP || FlagOutputImage == TRANSFORM) {			/* transpose versus transform */		if (FlagOutputImage == TRANSPOSE || FlagOutputImage == TRANSPOSE_WARP) stereotaxy_transpose_standard(ImgTarget, &IhTarget, ImgTargetStandard, &IhStandard, &OptimalTrans, &OptimalRot, &OptimalScale, InvMatTranslation);		else stereotaxy_transform_standard(ImgTarget, &IhTarget, ImgTargetStandard, &IhStandard, &OptimalTrans, &OptimalRot, &OptimalScale, InvMatTranslation);			/* write image */		printf("writing realigned image file: %s...\n", FnStrImage);		IhStandard.byteorder = IhTarget.byteorder;			/* match byteorder with target images */		write_image_matrix(FnStrImage, ImgTargetStandard, &IhStandard, INT_OutOfFieldCheck, OutofFieldValue, &FileFormat);	}	free(ImgTargetStandard);	/*** transform original target image to internal image ***/		/* calculate transform matrix */	printf("resampling target image...\n");	create_header_for_internal_matrix(&IhInternal);	create_header_for_resampled_matrix(&IhAtlas, &IhInternal, &IhAtlasInternal);	print_image_matrix_size(&IhAtlasInternal);	/* allocate memory for resampled image */	ImgTargetInternal = allocate_float_zero(image_size(&IhAtlasInternal), "ImgTargetInternal");		/* resample target image to internal matrix */	stereotaxy_transform_internal(ImgTarget, &IhTarget, ImgTargetInternal, &IhAtlasInternal, &OptimalTrans, &OptimalRot, &OptimalScale);	/* free original target image */	free(ImgTarget);		/* normalization */	multiply_image_with_constant(ImgTargetInternal, &IhAtlasInternal, INT_Global/NmTarget.avg, INT_OutOfFieldCheck, INT_OutOfFieldValue);	/*** resample stereotactic atlas to internal image ***/	/* read header */	printf("reading stereotactic atlas: %s...\n", FnAtlas);	ImgAtlas = allocate_float_zero(image_size(&IhAtlas), "ImgAtlas");	read_image_planes(FnAtlas, ImgAtlas, &IhAtlas, &ImAtlas, &FileFormat);		/* normalization */	multiply_image_with_constant(ImgAtlas, &IhAtlas, INT_Global/NmAtlas.avg, INT_OutOfFieldCheck, INT_OutOfFieldValue);	/* calculate transform matrix */	printf("resampling stereotactic atlas...\n");	create_header_for_internal_matrix(&IhInternal);	create_header_for_resampled_matrix(&IhAtlas, &IhInternal, &IhAtlasInternal);	resample_matrix3d_inv(&IhAtlas, &IhInternal, InvMatAtlasInternal);	print_image_matrix_size(&IhAtlasInternal);	/* allocate memory for resampled image */	ImgAtlasInternal = allocate_float_zero(image_size(&IhAtlasInternal), "ImgAtlasInternal");		/* transform image */	transform3d_inv_img(ImgAtlas, &IhAtlas, ImgAtlasInternal, &IhAtlasInternal, InvMatAtlasInternal, INT_OutOfFieldCheck, INT_OutOfFieldValue);	/* free memory */	free(ImgAtlas);		/* calculate ACPC level in the internal image matrix */	IntAcpcLevel = calculate_acpc_level(AtlasAcpc, InvMatAtlasInternal);	printf("ACPC level in the internal image matrix: %4.1f...\n", IntAcpcLevel);	/*** Draw standard stereotactic grids and create QC images ***/		/* draw stereotactic grids (determied on/off in the preference) */	if (FlagAPGrid != 0) {		printf("drawing stereotactic grids...\n");		draw_stereogrid3d(ImgAtlasInternal, IntAcpcLevel, AtlasAcpcCent, INT_Global*ColorGridMinor, INT_Global*ColorGridMajor);		draw_stereogrid3d(ImgTargetInternal, IntAcpcLevel, AtlasAcpcCent, INT_Global*ColorGridMinor, INT_Global*ColorGridMajor);	}		/* allocate memory for QC images */	ImgQc = allocate_float_zero(INT_Xd*INT_Yd*QC_SLICES, "ImgQc");	ImgSlice = allocate_float_zero(INT_Xd*INT_Yd, "ImgSlice");	create_header_for_internal_matrix(&IhQc);	IhQc.plane = 0;							/* initialize the number of planes */		/* create mid-sagittal slice */	midsagittal_slice(ImgTargetInternal, &IhAtlasInternal, ImgSlice, DisplayMsThick, INT_OutOfFieldCheck, INT_OutOfFieldValue);	add_slice_to_image(ImgQc, &IhQc, ImgSlice, QC_SLICES);	midsagittal_slice(ImgAtlasInternal, &IhAtlasInternal, ImgSlice, DisplayMsThick, INT_OutOfFieldCheck, INT_OutOfFieldValue);	add_slice_to_image(ImgQc, &IhQc, ImgSlice, QC_SLICES);		/* create midtransverse slice */	midtransverse_slice(ImgTargetInternal, &IhAtlasInternal, IntAcpcLevel, ImgSlice, DisplayMtThick, INT_OutOfFieldCheck, INT_OutOfFieldValue);	add_slice_to_image(ImgQc, &IhQc, ImgSlice, QC_SLICES);	midtransverse_slice(ImgAtlasInternal, &IhAtlasInternal, IntAcpcLevel, ImgSlice, DisplayMtThick, INT_OutOfFieldCheck, INT_OutOfFieldValue);	add_slice_to_image(ImgQc, &IhQc, ImgSlice, QC_SLICES);		/* create midcoronal slice */	midcoronal_slice(ImgTargetInternal, &IhAtlasInternal, ImgSlice, DisplayMcThick, INT_OutOfFieldCheck, INT_OutOfFieldValue);	add_slice_to_image(ImgQc, &IhQc, ImgSlice, QC_SLICES);	midcoronal_slice(ImgAtlasInternal, &IhAtlasInternal, ImgSlice, DisplayMcThick, INT_OutOfFieldCheck, INT_OutOfFieldValue);	add_slice_to_image(ImgQc, &IhQc, ImgSlice, QC_SLICES);		/* write *_str.img */	printf("writing QC image file: %s...\n", FnAcpcImage);	IhQc.byteorder = IhTarget.byteorder;	/* match byteorder with target images */	write_image_matrix(FnAcpcImage, ImgQc, &IhQc, INT_OutOfFieldCheck, OutofFieldValue, &FileFormat);		/* free images */	free(ImgQc);	free(ImgSlice);	free(ImgTargetInternal);	free(ImgAtlasInternal);/*** write *_str.lib file ***/	printf("writing stereotactic library file: %s...\n", FnStrLibrary);	read_internal_matrix_center(&CentInternal);	write_str_lib_file(FnStrLibrary, &OptimalTrans, &OptimalRot, &OptimalScale, &IhTarget, &IhInternal, &CentInternal, &IhStandard, &IntAcpcLevel);	/*** check flag ***/	if (FlagOutputImage == TRANSPOSE || FlagOutputImage == TRANSFORM) batchjob();	/****	LANDMARK DETECTION***/printf("\n*** Regional Anatomic Variance Estimation ***\n");/*** read *_str.lib file ***/	printf("reading stereotactic library file: %s...\n", FnStrLibrary);	read_str_lib_file(FnStrLibrary, &OptimalTrans, &OptimalRot, &OptimalScale, &IhTarget, &IhInternal, &CentInternal, &IhStandard, &IntAcpcLevel);/*** read landmark data ***/	/* allocate memory */	printf("reading landmark data...\n");	if ((PixCent = (Pixel3D *)calloc(LandmarkNumMax*2, sizeof(Pixel3D)))==NULL) print_error_message(1, "can't allocate memory for pixc");	if ((PixDest = (Pixel3D *)calloc(LandmarkNumMax*2, sizeof(Pixel3D)))==NULL) print_error_message(1, "can't allocate memory for pixe");	if ((PixSurf = (Pixel3D *)calloc(LandmarkNumMax*2, sizeof(Pixel3D)))==NULL) print_error_message(1, "can't allocate memory for pixs");	/* read file */	read_altaslandmark(FnLandmark, PixDest, PixCent, &LandmarkNum, LandmarkNumMax);	printf("number of hemispheric landmarks: %d...\n", LandmarkNum);/*** read standard atlas ***/	/* read header */	printf("reading stereotactic atlas: %s...\n", FnAtlas);	read_header(FnAtlas, &IhAtlas, &FileFormat);	print_image_matrix_size(&IhAtlas);	/* allocate memory */	ImgAtlas = allocate_float_zero(image_size(&IhAtlas), "ImgAtlas");		/* read image */	read_image_planes(FnAtlas, ImgAtlas, &IhAtlas, &ImAtlas, &FileFormat);	/* calculate normalization parameters */	norm_histogram(ImgAtlas, &IhAtlas, INT_OutOfFieldCheck, &INT_NormSet, &NmAtlas);	print_normvalue(&NmAtlas);/*** resample stereotactic atlas to internal matrix size ***/	/* calculate transform matrix */	printf("resampling stereotactic atlas...\n");	create_header_for_internal_matrix(&IhInternal);	create_header_for_resampled_matrix(&IhAtlas, &IhInternal, &IhAtlasInternal);	resample_matrix3d_inv(&IhAtlas, &IhInternal, InvMatAtlasInternal);	print_image_matrix_size(&IhAtlasInternal);	/* allocate memory for resampled image */	ImgAtlasInternal = allocate_float_zero(image_size(&IhAtlasInternal), "ImgAtlasInternal");		/* transform image */	transform3d_inv_img(ImgAtlas, &IhAtlas, ImgAtlasInternal, &IhAtlasInternal, InvMatAtlasInternal, INT_OutOfFieldCheck, INT_OutOfFieldValue);	/* free memory */	free(ImgAtlas);		/* calculate ACPC level in the internal image matrix */	IntAcpcLevel = calculate_acpc_level(AtlasAcpc, InvMatAtlasInternal);	printf("ACPC level in the internal image matrix: %4.1f...\n", IntAcpcLevel);	/*** bandpass filtering of Internalized target image prior to landmark detection ***/	/* set bandpass filter */	printf("smoothing the standard atlas (%d-%d)...\n", LandmarkCutoffLow, LandmarkCutoffHigh);	BandpassFilter = allocate_float_zero(LandmarkFilterWidth, "BandpassFilter");	bandpass_set_1d(BandpassFilter, LandmarkFilterWidth, 7, LandmarkCutoffLow, LandmarkCutoffHigh, &FilterScale);	/* '7' assumes 128 (2^7) data length for FFT calculation */	filter3d_sym_fov(ImgAtlasInternal, &IhAtlasInternal, BandpassFilter, LandmarkFilterWidth, FilterScale);	free(BandpassFilter);/*** convert stereotactic millimetric to internal pixel coordinates ***/	/* check internal matrix vs atlas dimensions, 03/12/2003 */	if (FlagLandmarkCoordinates == 1) {			printf("*** Pixel coordinates in the Landmark file ***\n");		printf("checking consistency between internal matrix and atlas dimensions...\n");		if ( compare_ImageHeader(&IhAtlasInternal, &IhInternal) == 0 ) print_error_message(1, "inconsistency between internal matrix and atlas dimensions");	}		/* covert stereotactic millimetric to pixel coordinates */	if (FlagLandmarkCoordinates == 0) {								/* added support for pixel coordinates, 03/12/2003 */			printf("converting millimetric to pixel coordinates...\n");		stereotactic_millimetric_to_internal_pixel(PixCent, IntAcpcLevel, LandmarkNum);		stereotactic_millimetric_to_internal_pixel(PixDest, IntAcpcLevel, LandmarkNum);			}	/* generate and append left hemisphere data */	printf("generating left hemispheric landmarks...\n");	add_left_from_right_internal_coordinates(PixCent, LandmarkNum);	/* this needs to be after millimetric_to_pixel conversion */	add_left_from_right_internal_coordinates(PixDest, LandmarkNum);	/* this needs to be after millimetric_to_pixel conversion */	LandmarkNumTotal = LandmarkNum * 2;	printf("total number of landmarks: %d...\n", LandmarkNumTotal);	/*** read target image file ***/	/* read header */	printf("reading target image file: %s...\n", FnTarget);	read_header(FnTargetHdr, &IhTarget, &FileFormat);	print_image_matrix_size(&IhTarget);	/* allocate memory */	ImgTarget = allocate_float_zero(image_size(&IhTarget), "ImgTarget");		/* read image */	read_image_planes(FnTarget, ImgTarget, &IhTarget, &ImTarget, &FileFormat);		/* calculate normalization parameters */	norm_histogram(ImgTarget, &IhTarget, INT_OutOfFieldCheck, &INT_NormSet, &NmTarget);	print_normvalue(&NmTarget);/*** resample target image to internal matrix size ***/	/* calculate transform matrix */	printf("resampling target image...\n");	create_header_for_internal_matrix(&IhInternal);	create_header_for_resampled_matrix(&IhAtlas, &IhInternal, &IhAtlasInternal);	print_image_matrix_size(&IhAtlasInternal);	/* allocate memory for resampled image */	ImgTargetInternal = allocate_float_zero(image_size(&IhAtlasInternal), "ImgTargetInternal");		/* resample target image to internal matrix */	stereotaxy_transform_internal(ImgTarget, &IhTarget, ImgTargetInternal, &IhAtlasInternal, &OptimalTrans, &OptimalRot, &OptimalScale);	/* free memory */	free(ImgTarget);		/*** bandpass filtering of Internalized target image prior to landmark detection ***/	/* set bandpass filter */	printf("smoothing target image (%d-%d)...\n", LandmarkCutoffLow, LandmarkCutoffHigh);	BandpassFilter = allocate_float_zero(LandmarkFilterWidth, "BandpassFilter");	bandpass_set_1d(BandpassFilter, LandmarkFilterWidth, 7, LandmarkCutoffLow, LandmarkCutoffHigh, &FilterScale);	/* '7' assumes 128 (2^7) data length for FFT calculation */	filter3d_sym_fov(ImgTargetInternal, &IhAtlasInternal, BandpassFilter, LandmarkFilterWidth, FilterScale);	free(BandpassFilter);	/*** determine regional stretching factors ***/	/* determine regional stretching */	printf("estimating regional variations...\n");	regional_matching(ImgTargetInternal, ImgAtlasInternal, &IhAtlasInternal, &NmTarget, &NmAtlas, PixDest, PixCent, PixSurf, LandmarkNumTotal);	free(ImgAtlasInternal);		/* check landmark asymmetry */	printf("removing too asymmetric landmarks (%d)...\n", check_landmarks(PixDest, PixCent, PixSurf, LandmarkNum));		/*** display and write landmarks ***/	/* display landmarks */	printf("displaying landmarks on target image...\n");	display_landmarks(ImgTargetInternal, &IhAtlasInternal, NmTarget.avg, PixSurf, PixDest, PixCent, LandmarkNumTotal);		/* write landmark image */	if (FlagLandmarkImage == YES) {		printf("writing landmark image file: %s...\n", FnLandmarkImage);		IhAtlasInternal.byteorder = IhTarget.byteorder;		/* match byte order with target images */		write_image_matrix(FnLandmarkImage, ImgTargetInternal, &IhAtlasInternal, INT_OutOfFieldCheck, OutofFieldValue, &FileFormat);	}	free(ImgTargetInternal);		/* convert landmarks to millimetric coordinates */	if (FlagLandmarkCoordinates == 0) {								/* added support for pixel coordinates, 03/12/2003 */			stereotactic_internal_pixel_to_millimetric(PixSurf, IntAcpcLevel, LandmarkNum);		stereotactic_internal_pixel_to_millimetric(PixDest, IntAcpcLevel, LandmarkNum);		stereotactic_internal_pixel_to_millimetric(PixCent, IntAcpcLevel, LandmarkNum);			}		/* output landmark file */	printf("writing landmark library file...\n");	write_landmarks(FnLandmarkLibrary, PixSurf, PixDest, PixCent, LandmarkNum);		/* free landmarks */	free(PixCent);	free(PixDest);	free(PixSurf);/*** check flag ***/	if (FlagOutputImage == NOIMAGE) batchjob();	/****	NON-LINEAR WARPING***/printf("\n*** Stereotactic Nonlinear Warping ***\n");/*** read *_str.lib file ***/	printf("reading stereotactic library file: %s...\n", FnStrLibrary);	read_str_lib_file(FnStrLibrary, &OptimalTrans, &OptimalRot, &OptimalScale, &IhTarget, &IhInternal, &CentInternal, &IhStandard, &IntAcpcLevel);/*** read landmarks ***/	/* allocate memory */	if ((PixCent = (Pixel3D *)calloc(LandmarkNumMax*2, sizeof(Pixel3D)))==NULL) print_error_message(1, "can't allocate memory for pixc");	if ((PixDest = (Pixel3D *)calloc(LandmarkNumMax*2, sizeof(Pixel3D)))==NULL) print_error_message(1, "can't allocate memory for pixe");	if ((PixSurf = (Pixel3D *)calloc(LandmarkNumMax*2, sizeof(Pixel3D)))==NULL) print_error_message(1, "can't allocate memory for pixs");	/* read landmark file */	printf("reading landmark library file...\n");	read_landmarks(FnLandmarkLibrary, PixSurf, PixDest, PixCent, &LandmarkNum);	printf("number of hemispheric landmarks: %d...\n", LandmarkNum);	LandmarkNumTotal = LandmarkNum * 2;	/* convert landmarks to internal pixel coordinates */	stereotactic_millimetric_to_internal_pixel(PixSurf, IntAcpcLevel, LandmarkNum);	stereotactic_millimetric_to_internal_pixel(PixDest, IntAcpcLevel, LandmarkNum);	/* remove zero (non-determined) landmarks */	printf("removing nondeterminant landmarks...\n");	remove_nondeterminant_landmark(PixSurf, PixDest, LandmarkNumTotal, &LandmarkNumEffective);	printf("total number of effective landmarks: %d...\n", LandmarkNumEffective);	/*** read target image file ***/	/* read header */	printf("reading target image file: %s...\n", FnTarget);	read_header(FnTargetHdr, &IhTarget, &FileFormat);	print_image_matrix_size(&IhTarget);	/* allocate memory */	ImgTarget = allocate_float_zero(image_size(&IhTarget), "ImgTarget");		/* read image */	read_image_planes(FnTarget, ImgTarget, &IhTarget, &ImTarget, &FileFormat);		/*** prepare standard output image ***/	/* prepare standard output image matrix */	printf("preparing output image matrix...\n");	create_header_for_standard_matrix(&IhStandard);	ImgTargetStandard = allocate_float_zero(image_size(&IhStandard), "ImgTargetStandard");	/* calculate ACPC level in the standard image matrix */	create_header_for_internal_matrix(&IhInternal);	resample_matrix3d_inv(&IhInternal, &IhStandard, InvMatInternalStandard);	StdAcpcLevel = calculate_acpc_level(IntAcpcLevel, InvMatInternalStandard);	AcpcTranslation.x = AcpcTranslation.y = 0.0;	AcpcTranslation.z = STD_Acpc - StdAcpcLevel;	translation3d_inv(&AcpcTranslation, InvMatTranslation);	printf("ACPC level: standard %4.1f (resampled %4.1f)...\n", STD_Acpc, StdAcpcLevel);	/* post warping transformation */	resample_matrix3d_inv(&IhInternal, &IhStandard, InvMatInternalStandard);	multiply_matrix4(InvMatInternalStandard, InvMatTranslation, InvMatPostWarp);	/* pre warping transformation */	resample_matrix3d_inv(&IhTarget, &IhInternal, InvMatTargetInternal);	read_internal_matrix_center(&CentInternal);	transpose_scale3d_inv(&OptimalRot, &OptimalTrans, &OptimalScale, &CentInternal, InvMatStr);	multiply_matrix4(InvMatTargetInternal, InvMatStr, InvMatPreWarp);		/*** nonlinear warping ***/	/* nonlinear warping */	tps_deform_stereotaxy(ImgTarget, &IhTarget, ImgTargetStandard, &IhStandard, InvMatPreWarp, PixSurf, PixDest, LandmarkNumEffective, InvMatPostWarp);		/* write *_str.img */	printf("writing standardized image file: %s...\n", FnWarpImage);	IhStandard.byteorder = IhTarget.byteorder;		/* match byte order with target images */	write_image_matrix(FnWarpImage, ImgTargetStandard, &IhStandard, INT_OutOfFieldCheck, OutofFieldValue, &FileFormat);		/* free landmarks */	free(PixCent);	free(PixDest);	free(PixSurf);		/* if MACOS, check BatchjobIndicator */	batchjob();}